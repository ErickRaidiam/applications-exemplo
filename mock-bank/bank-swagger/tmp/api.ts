// tslint:disable
/**
 * API Accounts - Open Banking Brasil
 * API de contas de depósito à vista, contas de poupança e contas pré-pagas do Open Banking Brasil – Fase 2. API que retorna informações de contas de depósito à vista, contas de poupança e contas de pagamento pré-pagas mantidas nas instituições transmissoras por seus clientes, incluindo dados de identificação da conta, saldos, limites e transações.\\ Não possui segregação entre pessoa natural e pessoa jurídica.\\ Requer consentimento do cliente para todos os `endpoints`.  # Orientações A `Role`  do diretório de participantes relacionada à presente API é a `DADOS`.\\ Para todos os `endpoints` desta API é previsto o envio de um `token` através do header `Authorization`.\\ Este token deverá estar relacionado ao consentimento (`consentId`) mantido na instituição transmissora dos dados, o qual permitirá a pesquisa e retorno, na API em questão, dos  dados relacionados ao `consentId` específico relacionado.\\ Os dados serão devolvidos na consulta desde que o `consentId` relacionado corresponda a um consentimento válido e com o status `AUTHORISED`.\\ É também necessário que o recurso em questão (conta, contrato, etc) esteja disponível na instituição transmissora (ou seja, sem boqueios de qualquer natureza e com todas as autorizações/consentimentos já autorizados).\\ Além disso as `permissions` necessárias deverão ter sido solicitadas quando da criação do consentimento relacionado (`consentId`).\\ Relacionamos a seguir as `permissions` necessárias para a consulta de dados em cada `endpoint` da presente API.  ## Permissions necessárias para a API Accounts  Para cada um dos paths desta API, além dos escopos (`scopes`) indicados existem `permissions` que deverão ser observadas:  ### `/accounts`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}`   - permissions:     - GET: **ACCOUNTS_READ** ### `/accounts/{accountId}/balances`   - permissions:     - GET: **ACCOUNTS_BALANCES_READ** ### `/accounts/{accountId}/transactions`   - permissions:     - GET: **ACCOUNTS_TRANSACTIONS_READ** ### `/accounts/{accountId}/overdraft-limits`   - permissions:     - GET: **ACCOUNTS_OVERDRAFT_LIMITS_READ** 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: gt-interfaces@openbankingbr.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga 
 * @export
 * @interface AccountBalancesData
 */
export interface AccountBalancesData {
    /**
     * Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Admite saldo negativo. Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    availableAmount: number | null;
    /**
     * Moeda referente ao valor do saldo disponível, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    availableAmountCurrency: string;
    /**
     * Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    blockedAmount: number | null;
    /**
     * Moeda referente ao valor do saldo bloqueado, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    blockedAmountCurrency: string;
    /**
     * Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática Expresso em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountBalancesData
     */
    automaticallyInvestedAmount: number | null;
    /**
     * Moeda referente ao valor do saldo disponível com aplicação automática, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountBalancesData
     */
    automaticallyInvestedAmountCurrency: string;
}
/**
 * 
 * @export
 * @interface AccountData
 */
export interface AccountData {
    /**
     * Nome da Marca reportada pelo participante do Open Banking. O conceito a que se refere a \'marca\' é em essência uma promessa da empresa em fornecer uma série específica de atributos, benefícios e serviços uniformes aos clientes.
     * @type {string}
     * @memberof AccountData
     */
    brandName: string;
    /**
     * Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
     * @type {string}
     * @memberof AccountData
     */
    companyCnpj: string;
    /**
     * 
     * @type {EnumAccountType}
     * @memberof AccountData
     */
    type: EnumAccountType;
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
     * @type {string}
     * @memberof AccountData
     */
    compeCode: string;
    /**
     * Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
     * @type {string}
     * @memberof AccountData
     */
    branchCode: string;
    /**
     * Número da conta
     * @type {string}
     * @memberof AccountData
     */
    number: string;
    /**
     * Dígito da conta
     * @type {string}
     * @memberof AccountData
     */
    checkDigit: string;
    /**
     * Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
     * @type {string}
     * @memberof AccountData
     */
    accountID: string;
}
/**
 * Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga 
 * @export
 * @interface AccountIdentificationData
 */
export interface AccountIdentificationData {
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
     * @type {string}
     * @memberof AccountIdentificationData
     */
    compeCode: string;
    /**
     * Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória) 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    branchCode: string;
    /**
     * Número da conta 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    number: string;
    /**
     * Dígito da conta 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    checkDigit: string;
    /**
     * 
     * @type {EnumAccountType}
     * @memberof AccountIdentificationData
     */
    type: EnumAccountType;
    /**
     * 
     * @type {EnumAccountSubType}
     * @memberof AccountIdentificationData
     */
    subtype: EnumAccountSubType;
    /**
     * Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. \'BRL\'  Todos os saldos informados estão representados com a moeda vigente do Brasil 
     * @type {string}
     * @memberof AccountIdentificationData
     */
    currency: string;
}
/**
 * Conjunto de informações da Conta de: depósito à vista 
 * @export
 * @interface AccountOverdraftLimitsData
 */
export interface AccountOverdraftLimitsData {
    /**
     * Valor do limite contratado do cheque especial.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftContractedLimit: number | null;
    /**
     * Moeda referente ao valor do limite contratado do cheque especial, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftContractedLimitCurrency: string;
    /**
     * Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftUsedLimit: number | null;
    /**
     * Moeda referente ao valor utilizado total do limite do cheque especial e o adiantamento a depositante, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    overdraftUsedLimitCurrency: string;
    /**
     * Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
     * @type {number}
     * @memberof AccountOverdraftLimitsData
     */
    unarrangedOverdraftAmount: number | null;
    /**
     * Moeda referente ao valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial, segundo modelo ISO-4217. p.ex. \'BRL\'. Pode ser preenchido com “NA” caso a instituição não possua a informação.
     * @type {string}
     * @memberof AccountOverdraftLimitsData
     */
    unarrangedOverdraftAmountCurrency: string;
}
/**
 * 
 * @export
 * @interface AccountTransactionsData
 */
export interface AccountTransactionsData {
    /**
     * Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionId?: string;
    /**
     * 
     * @type {EnumCompletedAuthorisedPaymentIndicator}
     * @memberof AccountTransactionsData
     */
    completedAuthorisedPaymentType: EnumCompletedAuthorisedPaymentIndicator;
    /**
     * 
     * @type {EnumCreditDebitIndicator}
     * @memberof AccountTransactionsData
     */
    creditDebitType: EnumCreditDebitIndicator;
    /**
     * Campo livre que corresponde ao identificador da transação na instituição financeira
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionName: string;
    /**
     * 
     * @type {EnumTransactionTypes}
     * @memberof AccountTransactionsData
     */
    type: EnumTransactionTypes;
    /**
     * Valor da transação. Expressa em valor monetário com 4 casas decimais.
     * @type {number}
     * @memberof AccountTransactionsData
     */
    amount: number;
    /**
     * Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. \'BRL\'.
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionCurrency: string;
    /**
     * Se indicador de transação: TRANSACAO_EFETIVADA - corresponde a data de lançamento da transação LANCAMENTO_FUTURO - corresponde a data prevista de efetivação da transação 
     * @type {string}
     * @memberof AccountTransactionsData
     */
    transactionDate: string;
    /**
     * Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação) 
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCnpjCpf: string;
    /**
     * 
     * @type {EnumPartiePersonType}
     * @memberof AccountTransactionsData
     */
    partiePersonType: EnumPartiePersonType;
    /**
     * Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe). O campo tem a anotação “n/a” (“não se aplica”) para os participantes do STR aos quais não é atribuído um número-código
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCompeCode: string;
    /**
     * Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieBranchCode: string;
    /**
     * Número da conta da pessoa envolvida na transação
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieNumber: string;
    /**
     * Dígito da conta da pessoa envolvida na transação
     * @type {string}
     * @memberof AccountTransactionsData
     */
    partieCheckDigit: string;
}
/**
 * Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
 * @export
 * @interface BusinessEntity
 */
export interface BusinessEntity {
    /**
     * 
     * @type {BusinessEntityDocument}
     * @memberof BusinessEntity
     */
    document: BusinessEntityDocument;
}
/**
 * 
 * @export
 * @interface BusinessEntityDocument
 */
export interface BusinessEntityDocument {
    /**
     * Número do documento de identificação oficial do titular pessoa jurídica.
     * @type {string}
     * @memberof BusinessEntityDocument
     */
    identification: string;
    /**
     * Tipo do documento de identificação oficial do titular pessoa jurídica.
     * @type {string}
     * @memberof BusinessEntityDocument
     */
    rel: string;
}
/**
 * 
 * @export
 * @interface CreateConsent
 */
export interface CreateConsent {
    /**
     * 
     * @type {CreateConsentData}
     * @memberof CreateConsent
     */
    data: CreateConsentData;
}
/**
 * 
 * @export
 * @interface CreateConsentData
 */
export interface CreateConsentData {
    /**
     * 
     * @type {LoggedUser}
     * @memberof CreateConsentData
     */
    loggedUser: LoggedUser;
    /**
     * 
     * @type {BusinessEntity}
     * @memberof CreateConsentData
     */
    businessEntity?: BusinessEntity;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateConsentData
     */
    permissions: Array<CreateConsentDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof CreateConsentData
     */
    expirationDateTime?: Date;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof CreateConsentData
     */
    transactionFromDateTime?: Date;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof CreateConsentData
     */
    transactionToDateTime?: Date;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateConsentDataPermissionsEnum {
    ACCOUNTSREAD = 'ACCOUNTS_READ',
    ACCOUNTSBALANCESREAD = 'ACCOUNTS_BALANCES_READ',
    ACCOUNTSTRANSACTIONSREAD = 'ACCOUNTS_TRANSACTIONS_READ',
    ACCOUNTSOVERDRAFTLIMITSREAD = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CREDITCARDSACCOUNTSREAD = 'CREDIT_CARDS_ACCOUNTS_READ',
    CREDITCARDSACCOUNTSBILLSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CREDITCARDSACCOUNTSLIMITSREAD = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CREDITCARDSACCOUNTSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CUSTOMERSPERSONALIDENTIFICATIONSREAD = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CUSTOMERSPERSONALADITTIONALINFOREAD = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CUSTOMERSBUSINESSIDENTIFICATIONSREAD = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CUSTOMERSBUSINESSADITTIONALINFOREAD = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FINANCINGSREAD = 'FINANCINGS_READ',
    FINANCINGSSCHEDULEDINSTALMENTSREAD = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FINANCINGSPAYMENTSREAD = 'FINANCINGS_PAYMENTS_READ',
    FINANCINGSWARRANTIESREAD = 'FINANCINGS_WARRANTIES_READ',
    INVOICEFINANCINGSREAD = 'INVOICE_FINANCINGS_READ',
    INVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    INVOICEFINANCINGSPAYMENTSREAD = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    INVOICEFINANCINGSWARRANTIESREAD = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LOANSREAD = 'LOANS_READ',
    LOANSSCHEDULEDINSTALMENTSREAD = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LOANSPAYMENTSREAD = 'LOANS_PAYMENTS_READ',
    LOANSWARRANTIESREAD = 'LOANS_WARRANTIES_READ',
    UNARRANGEDACCOUNTSOVERDRAFTREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    RESOURCESREAD = 'RESOURCES_READ'
}

/**
 * Subtipo de conta (vide Enum):  Conta individual - possui um único titular Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta. Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares 
 * @export
 * @enum {string}
 */
export enum EnumAccountSubType {
    INDIVIDUAL = 'INDIVIDUAL',
    CONJUNTASIMPLES = 'CONJUNTA_SIMPLES',
    CONJUNTASOLIDARIA = 'CONJUNTA_SOLIDARIA'
}

/**
 * Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a \'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados\' 
 * @export
 * @enum {string}
 */
export enum EnumAccountType {
    DEPOSITOAVISTA = 'CONTA_DEPOSITO_A_VISTA',
    POUPANCA = 'CONTA_POUPANCA',
    PAGAMENTOPREPAGA = 'CONTA_PAGAMENTO_PRE_PAGA'
}

/**
 * Indicador da transação:  - Transação efetivada - Lançamento futuro 
 * @export
 * @enum {string}
 */
export enum EnumCompletedAuthorisedPaymentIndicator {
    TRANSACAOEFETIVADA = 'TRANSACAO_EFETIVADA',
    LANCAMENTOFUTURO = 'LANCAMENTO_FUTURO'
}

/**
 * Indicador do tipo de lançamento:  Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente. Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente. 
 * @export
 * @enum {string}
 */
export enum EnumCreditDebitIndicator {
    CREDITO = 'CREDITO',
    DEBITO = 'DEBITO'
}

/**
 * Identificação do Tipo de Pessoa da pessoa envolvida na transação. Pessoa Natural - Informar CPF no campo “payerCnpjCpf” Pessoa Jurídica - Informar CNPJ no campo “payerCnpjCpf” 
 * @export
 * @enum {string}
 */
export enum EnumPartiePersonType {
    NATURAL = 'PESSOA_NATURAL',
    JURIDICA = 'PESSOA_JURIDICA'
}

/**
 * Tipo de Transação 
 * @export
 * @enum {string}
 */
export enum EnumTransactionTypes {
    TED = 'TED',
    DOC = 'DOC',
    PIX = 'PIX',
    TRANSFERENCIAMESMAINSTITUICAO = 'TRANSFERENCIA_MESMA_INSTITUICAO',
    BOLETO = 'BOLETO',
    CONVENIOARRECADACAO = 'CONVENIO_ARRECADACAO',
    PACOTETARIFASERVICOS = 'PACOTE_TARIFA_SERVICOS',
    TARIFASERVICOSAVULSOS = 'TARIFA_SERVICOS_AVULSOS',
    FOLHAPAGAMENTO = 'FOLHA_PAGAMENTO',
    DEPOSITO = 'DEPOSITO',
    SAQUE = 'SAQUE',
    CARTAO = 'CARTAO',
    ENCARGOSJUROSCHEQUEESPECIAL = 'ENCARGOS_JUROS_CHEQUE_ESPECIAL',
    RENDIMENTOAPLICFINANCEIRA = 'RENDIMENTO_APLIC_FINANCEIRA',
    PORTABILIDADESALARIO = 'PORTABILIDADE_SALARIO',
    RESGATEAPLICFINANCEIRA = 'RESGATE_APLIC_FINANCEIRA',
    OPERACAOCREDITO = 'OPERACAO_CREDITO',
    OUTROS = 'OUTROS'
}

/**
 * 
 * @export
 * @interface Introspection
 */
export interface Introspection {
    /**
     * if the token has expired
     * @type {boolean}
     * @memberof Introspection
     */
    active?: boolean;
    /**
     * id of client who owns the token
     * @type {string}
     * @memberof Introspection
     */
    clientId?: string;
    /**
     * expiration time in ms
     * @type {string}
     * @memberof Introspection
     */
    exp?: string;
    /**
     * when the token was issued
     * @type {string}
     * @memberof Introspection
     */
    iat?: string;
    /**
     * the issuer
     * @type {string}
     * @memberof Introspection
     */
    iss?: string;
    /**
     * unique string
     * @type {string}
     * @memberof Introspection
     */
    jti?: string;
    /**
     * scope
     * @type {string}
     * @memberof Introspection
     */
    scope?: string;
    /**
     * type of token
     * @type {string}
     * @memberof Introspection
     */
    tokenType?: string;
    /**
     * subject of token (not always present, depending on the token)
     * @type {string}
     * @memberof Introspection
     */
    sub?: string;
}
/**
 * 
 * @export
 * @interface IntrospectionRequest
 */
export interface IntrospectionRequest {
    /**
     * Oauth 2.0 token to be introspected
     * @type {string}
     * @memberof IntrospectionRequest
     */
    token: string;
}
/**
 * Referências para outros recusos da API requisitada.
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * URI completo que gerou a resposta atual.
     * @type {string}
     * @memberof Links
     */
    self: string;
    /**
     * URI da primeira página que originou essa lista de resultados. Restrição - Obrigatório quando não for a primeira página da resposta
     * @type {string}
     * @memberof Links
     */
    first?: string;
    /**
     * URI da página anterior dessa lista de resultados. Restrição -  Obrigatório quando não for a primeira página da resposta
     * @type {string}
     * @memberof Links
     */
    prev?: string;
    /**
     * URI da próxima página dessa lista de resultados. Restrição - Obrigatório quando não for a última página da resposta
     * @type {string}
     * @memberof Links
     */
    next?: string;
    /**
     * URI da última página dessa lista de resultados. Restrição - Obrigatório quando não for a última página da resposta
     * @type {string}
     * @memberof Links
     */
    last?: string;
}
/**
 * Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
 * @export
 * @interface LoggedUser
 */
export interface LoggedUser {
    /**
     * 
     * @type {LoggedUserDocument}
     * @memberof LoggedUser
     */
    document: LoggedUserDocument;
}
/**
 * 
 * @export
 * @interface LoggedUserDocument
 */
export interface LoggedUserDocument {
    /**
     * Número do documento de identificação oficial do usuário.
     * @type {string}
     * @memberof LoggedUserDocument
     */
    identification: string;
    /**
     * Tipo do documento de identificação oficial do usuário.
     * @type {string}
     * @memberof LoggedUserDocument
     */
    rel: string;
}
/**
 * Meta informações referente a API requisitada.
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * Número total de registros no resultado
     * @type {number}
     * @memberof Meta
     */
    totalRecords: number;
    /**
     * Número total de páginas no resultado
     * @type {number}
     * @memberof Meta
     */
    totalPages: number;
    /**
     * Data e hora da consulta, conforme especificação RFC-3339, formato UTC.
     * @type {Date}
     * @memberof Meta
     */
    requestDateTime: Date;
}
/**
 * 
 * @export
 * @interface ResponseAccountBalances
 */
export interface ResponseAccountBalances {
    /**
     * 
     * @type {AccountBalancesData}
     * @memberof ResponseAccountBalances
     */
    data: AccountBalancesData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountBalances
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountBalances
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountIdentification
 */
export interface ResponseAccountIdentification {
    /**
     * 
     * @type {AccountIdentificationData}
     * @memberof ResponseAccountIdentification
     */
    data: AccountIdentificationData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountIdentification
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountIdentification
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountList
 */
export interface ResponseAccountList {
    /**
     * Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
     * @type {Array<AccountData>}
     * @memberof ResponseAccountList
     */
    data: Array<AccountData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountList
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountList
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountOverdraftLimits
 */
export interface ResponseAccountOverdraftLimits {
    /**
     * 
     * @type {AccountOverdraftLimitsData}
     * @memberof ResponseAccountOverdraftLimits
     */
    data: AccountOverdraftLimitsData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountOverdraftLimits
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountOverdraftLimits
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseAccountTransactions
 */
export interface ResponseAccountTransactions {
    /**
     * Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga 
     * @type {Array<AccountTransactionsData>}
     * @memberof ResponseAccountTransactions
     */
    data: Array<AccountTransactionsData>;
    /**
     * 
     * @type {Links}
     * @memberof ResponseAccountTransactions
     */
    links: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseAccountTransactions
     */
    meta: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsent
 */
export interface ResponseConsent {
    /**
     * 
     * @type {ResponseConsentData}
     * @memberof ResponseConsent
     */
    data: ResponseConsentData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseConsent
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseConsent
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsentData
 */
export interface ResponseConsentData {
    /**
     * Identificador único do consentimento.
     * @type {string}
     * @memberof ResponseConsentData
     */
    consentId: string;
    /**
     * Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentData
     */
    creationDateTime: Date;
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof ResponseConsentData
     */
    status: ResponseConsentDataStatusEnum;
    /**
     * Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentData
     */
    statusUpdateDateTime: Date;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentData
     */
    permissions: Array<ResponseConsentDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentData
     */
    expirationDateTime?: Date;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentData
     */
    transactionFromDateTime?: Date;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentData
     */
    transactionToDateTime?: Date;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentDataStatusEnum {
    AUTHORISED = 'AUTHORISED',
    AWAITINGAUTHORISATION = 'AWAITING_AUTHORISATION',
    REJECTED = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentDataPermissionsEnum {
    ACCOUNTSREAD = 'ACCOUNTS_READ',
    ACCOUNTSBALANCESREAD = 'ACCOUNTS_BALANCES_READ',
    ACCOUNTSTRANSACTIONSREAD = 'ACCOUNTS_TRANSACTIONS_READ',
    ACCOUNTSOVERDRAFTLIMITSREAD = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CREDITCARDSACCOUNTSREAD = 'CREDIT_CARDS_ACCOUNTS_READ',
    CREDITCARDSACCOUNTSBILLSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CREDITCARDSACCOUNTSLIMITSREAD = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CREDITCARDSACCOUNTSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CUSTOMERSPERSONALIDENTIFICATIONSREAD = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CUSTOMERSPERSONALADITTIONALINFOREAD = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CUSTOMERSBUSINESSIDENTIFICATIONSREAD = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CUSTOMERSBUSINESSADITTIONALINFOREAD = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FINANCINGSREAD = 'FINANCINGS_READ',
    FINANCINGSSCHEDULEDINSTALMENTSREAD = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FINANCINGSPAYMENTSREAD = 'FINANCINGS_PAYMENTS_READ',
    FINANCINGSWARRANTIESREAD = 'FINANCINGS_WARRANTIES_READ',
    INVOICEFINANCINGSREAD = 'INVOICE_FINANCINGS_READ',
    INVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    INVOICEFINANCINGSPAYMENTSREAD = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    INVOICEFINANCINGSWARRANTIESREAD = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LOANSREAD = 'LOANS_READ',
    LOANSSCHEDULEDINSTALMENTSREAD = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LOANSPAYMENTSREAD = 'LOANS_PAYMENTS_READ',
    LOANSWARRANTIESREAD = 'LOANS_WARRANTIES_READ',
    UNARRANGEDACCOUNTSOVERDRAFTREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    RESOURCESREAD = 'RESOURCES_READ'
}

/**
 * 
 * @export
 * @interface ResponseConsentFull
 */
export interface ResponseConsentFull {
    /**
     * 
     * @type {ResponseConsentFullData}
     * @memberof ResponseConsentFull
     */
    data: ResponseConsentFullData;
    /**
     * 
     * @type {Links}
     * @memberof ResponseConsentFull
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseConsentFull
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseConsentFullData
 */
export interface ResponseConsentFullData {
    /**
     * Identificador único do consentimento.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    consentId: string;
    /**
     * OpenID Subject of the Authenitcating User
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    sub?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    linkedAccountIds?: Array<string>;
    /**
     * Identification of the client that made the request.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    clientId: string;
    /**
     * Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentFullData
     */
    creationDateTime: Date;
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof ResponseConsentFullData
     */
    status: ResponseConsentFullDataStatusEnum;
    /**
     * Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentFullData
     */
    statusUpdateDateTime: Date;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseConsentFullData
     */
    permissions: Array<ResponseConsentFullDataPermissionsEnum>;
    /**
     * Data e hora de expiração da permissão. Se não for preenchido, a permissão terá a data aberta. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentFullData
     */
    expirationDateTime?: Date;
    /**
     * Data e hora da transação inicial. Se não for preenchido, a transação terá a data aberta e a data será retornada com a primeira transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentFullData
     */
    transactionFromDateTime?: Date;
    /**
     * Data e hora final da transação. Se não for preenchido, a transação terá a data aberta e a data será retornada com a ultima transação disponível. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
     * @type {Date}
     * @memberof ResponseConsentFullData
     */
    transactionToDateTime?: Date;
    /**
     * 
     * @type {LoggedUser}
     * @memberof ResponseConsentFullData
     */
    loggedUser: LoggedUser;
    /**
     * 
     * @type {BusinessEntity}
     * @memberof ResponseConsentFullData
     */
    businessEntity?: BusinessEntity;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentFullDataStatusEnum {
    AUTHORISED = 'AUTHORISED',
    AWAITINGAUTHORISATION = 'AWAITING_AUTHORISATION',
    REJECTED = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum ResponseConsentFullDataPermissionsEnum {
    ACCOUNTSREAD = 'ACCOUNTS_READ',
    ACCOUNTSBALANCESREAD = 'ACCOUNTS_BALANCES_READ',
    ACCOUNTSTRANSACTIONSREAD = 'ACCOUNTS_TRANSACTIONS_READ',
    ACCOUNTSOVERDRAFTLIMITSREAD = 'ACCOUNTS_OVERDRAFT_LIMITS_READ',
    CREDITCARDSACCOUNTSREAD = 'CREDIT_CARDS_ACCOUNTS_READ',
    CREDITCARDSACCOUNTSBILLSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_READ',
    CREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ',
    CREDITCARDSACCOUNTSLIMITSREAD = 'CREDIT_CARDS_ACCOUNTS_LIMITS_READ',
    CREDITCARDSACCOUNTSTRANSACTIONSREAD = 'CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ',
    CUSTOMERSPERSONALIDENTIFICATIONSREAD = 'CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ',
    CUSTOMERSPERSONALADITTIONALINFOREAD = 'CUSTOMERS_PERSONAL_ADITTIONALINFO_READ',
    CUSTOMERSBUSINESSIDENTIFICATIONSREAD = 'CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ',
    CUSTOMERSBUSINESSADITTIONALINFOREAD = 'CUSTOMERS_BUSINESS_ADITTIONALINFO_READ',
    FINANCINGSREAD = 'FINANCINGS_READ',
    FINANCINGSSCHEDULEDINSTALMENTSREAD = 'FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    FINANCINGSPAYMENTSREAD = 'FINANCINGS_PAYMENTS_READ',
    FINANCINGSWARRANTIESREAD = 'FINANCINGS_WARRANTIES_READ',
    INVOICEFINANCINGSREAD = 'INVOICE_FINANCINGS_READ',
    INVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD = 'INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ',
    INVOICEFINANCINGSPAYMENTSREAD = 'INVOICE_FINANCINGS_PAYMENTS_READ',
    INVOICEFINANCINGSWARRANTIESREAD = 'INVOICE_FINANCINGS_WARRANTIES_READ',
    LOANSREAD = 'LOANS_READ',
    LOANSSCHEDULEDINSTALMENTSREAD = 'LOANS_SCHEDULED_INSTALMENTS_READ',
    LOANSPAYMENTSREAD = 'LOANS_PAYMENTS_READ',
    LOANSWARRANTIESREAD = 'LOANS_WARRANTIES_READ',
    UNARRANGEDACCOUNTSOVERDRAFTREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_READ',
    UNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ',
    UNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD = 'UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ',
    RESOURCESREAD = 'RESOURCES_READ'
}

/**
 * 
 * @export
 * @interface ResponseError
 */
export interface ResponseError {
    /**
     * 
     * @type {Array<ResponseErrorErrors>}
     * @memberof ResponseError
     */
    errors: Array<ResponseErrorErrors>;
    /**
     * 
     * @type {Meta}
     * @memberof ResponseError
     */
    meta?: Meta;
}
/**
 * 
 * @export
 * @interface ResponseErrorErrors
 */
export interface ResponseErrorErrors {
    /**
     * Código de erro específico do endpoint
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    code: string;
    /**
     * Título legível por humanos deste erro específico
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    title: string;
    /**
     * Descrição legível por humanos deste erro específico
     * @type {string}
     * @memberof ResponseErrorErrors
     */
    detail: string;
}
/**
 * 
 * @export
 * @interface UpdateConsent
 */
export interface UpdateConsent {
    /**
     * 
     * @type {UpdateConsentData}
     * @memberof UpdateConsent
     */
    data: UpdateConsentData;
}
/**
 * 
 * @export
 * @interface UpdateConsentData
 */
export interface UpdateConsentData {
    /**
     * Estado atual do consentimento cadastrado.
     * @type {string}
     * @memberof UpdateConsentData
     */
    status?: UpdateConsentDataStatusEnum;
    /**
     * OpenID Subject of the Authenitcating User
     * @type {string}
     * @memberof UpdateConsentData
     */
    sub?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateConsentData
     */
    linkedAccountIds?: Array<string>;
    /**
     * Identification of the client that made the request.
     * @type {string}
     * @memberof UpdateConsentData
     */
    clientId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateConsentDataStatusEnum {
    AUTHORISED = 'AUTHORISED',
    AWAITINGAUTHORISATION = 'AWAITING_AUTHORISATION',
    REJECTED = 'REJECTED'
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['accountType'] = accountType;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAccountsAccountId.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountsAccountId.');
            }
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAccountsAccountIdBalances.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountsAccountIdBalances.');
            }
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAccountsAccountIdOverdraftLimits.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountsAccountIdOverdraftLimits.');
            }
            const localVarPath = `/accounts/{accountId}/overdraft-limits`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAccountsAccountIdTransactions.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountsAccountIdTransactions.');
            }
            const localVarPath = `/accounts/{accountId}/transactions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (fromBookingDate !== undefined) {
                localVarQueryParameter['fromBookingDate'] = (fromBookingDate as any instanceof Date) ?
                    (fromBookingDate as any).toISOString().substr(0,10) :
                    fromBookingDate;
            }

            if (toBookingDate !== undefined) {
                localVarQueryParameter['toBookingDate'] = (toBookingDate as any instanceof Date) ?
                    (toBookingDate as any).toISOString().substr(0,10) :
                    toBookingDate;
            }

            if (creditDebitIndicator !== undefined) {
                localVarQueryParameter['creditDebitIndicator'] = creditDebitIndicator;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountsAccountId(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getUserAccountsAccountId.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserAccountsAccountId.');
            }
            const localVarPath = `/user/{userId}/accounts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OpenId required

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountList> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountIdentification> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountBalances> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountOverdraftLimits> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountTransactions> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountsAccountId(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAccountIdentification> {
            const localVarAxiosArgs = AccountsApiAxiosParamCreator(configuration).getUserAccountsAccountId(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
         * @summary Obtém a lista de contas consentidas pelo cliente.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any): AxiosPromise<ResponseAccountList> {
            return AccountsApiFp(configuration).getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options)(axios, basePath);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountIdentification> {
            return AccountsApiFp(configuration).getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os saldos da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountBalances> {
            return AccountsApiFp(configuration).getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os limites da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountOverdraftLimits> {
            return AccountsApiFp(configuration).getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém a lista de transações da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
         * @param {number} [pageSize] Quantidade total de registros por páginas.
         * @param {string} [fromBookingDate] Data inicial de filtragem.
         * @param {string} [toBookingDate] Data final de filtragem.
         * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any): AxiosPromise<ResponseAccountTransactions> {
            return AccountsApiFp(configuration).getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options)(axios, basePath);
        },
        /**
         * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
         * @summary Obtém os dados de identificação da conta identificada por accountId.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} userId Unique UserId User
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountsAccountId(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseAccountIdentification> {
            return AccountsApiFp(configuration).getUserAccountsAccountId(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Método para obter a lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento.
     * @summary Obtém a lista de contas consentidas pelo cliente.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {EnumAccountType} [accountType] Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, accountType?: EnumAccountType, options?: any) {
        return AccountsApiFp(this.configuration).getAccounts(authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, accountType, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountId(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountId(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter os saldos da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os saldos da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdBalances(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdBalances(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter os limites da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os limites da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdOverdraftLimits(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdOverdraftLimits(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter a lista de transações da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém a lista de transações da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} accountId Identificador da conta de depósito à vista, de poupança ou de pagamento pré-paga.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {number} [page] Número da página que está sendo requisitada (o valor da primeira página é 1).
     * @param {number} [pageSize] Quantidade total de registros por páginas.
     * @param {string} [fromBookingDate] Data inicial de filtragem.
     * @param {string} [toBookingDate] Data final de filtragem.
     * @param {EnumCreditDebitIndicator} [creditDebitIndicator] Indicador do tipo de lançamento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountsAccountIdTransactions(authorization: string, accountId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, page?: number, pageSize?: number, fromBookingDate?: string, toBookingDate?: string, creditDebitIndicator?: EnumCreditDebitIndicator, options?: any) {
        return AccountsApiFp(this.configuration).getAccountsAccountIdTransactions(authorization, accountId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, page, pageSize, fromBookingDate, toBookingDate, creditDebitIndicator, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter os dados de identificação da conta de depósito à vista, poupança ou pagamento pré-paga identificada por accountId mantida pelo cliente na instituição transmissora.
     * @summary Obtém os dados de identificação da conta identificada por accountId.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} userId Unique UserId User
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getUserAccountsAccountId(authorization: string, userId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AccountsApiFp(this.configuration).getUserAccountsAccountId(authorization, userId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

}


/**
 * ConsentsApi - axios parameter creator
 * @export
 */
export const ConsentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'consentId' is not null or undefined
            if (consentId === null || consentId === undefined) {
                throw new RequiredError('consentId','Required parameter consentId was null or undefined when calling consentsDeleteConsentsConsentId.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling consentsDeleteConsentsConsentId.');
            }
            const localVarPath = `/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth2Security", ["consents"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'consentId' is not null or undefined
            if (consentId === null || consentId === undefined) {
                throw new RequiredError('consentId','Required parameter consentId was null or undefined when calling consentsGetConsentsConsentId.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling consentsGetConsentsConsentId.');
            }
            const localVarPath = `/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth2Security", ["consents"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling consentsPostConsents.');
            }
            // verify required parameter 'createConsent' is not null or undefined
            if (createConsent === null || createConsent === undefined) {
                throw new RequiredError('createConsent','Required parameter createConsent was null or undefined when calling consentsPostConsents.');
            }
            const localVarPath = `/consents`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth2Security", ["consents"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication authorizer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof createConsent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createConsent !== undefined ? createConsent : {}) : (createConsent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'consentId' is not null or undefined
            if (consentId === null || consentId === undefined) {
                throw new RequiredError('consentId','Required parameter consentId was null or undefined when calling consentsPutConsents.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling consentsPutConsents.');
            }
            // verify required parameter 'updateConsent' is not null or undefined
            if (updateConsent === null || updateConsent === undefined) {
                throw new RequiredError('updateConsent','Required parameter updateConsent was null or undefined when calling consentsPutConsents.');
            }
            const localVarPath = `/consents/{consentId}`
                .replace(`{${"consentId"}}`, encodeURIComponent(String(consentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("OAuth2Security", ["consents"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof updateConsent !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateConsent !== undefined ? updateConsent : {}) : (updateConsent || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsentsApi - functional programming interface
 * @export
 */
export const ConsentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ConsentsApiAxiosParamCreator(configuration).consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsent | ResponseConsentFull> {
            const localVarAxiosArgs = ConsentsApiAxiosParamCreator(configuration).consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsent> {
            const localVarAxiosArgs = ConsentsApiAxiosParamCreator(configuration).consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseConsentFull> {
            const localVarAxiosArgs = ConsentsApiAxiosParamCreator(configuration).consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConsentsApi - factory interface
 * @export
 */
export const ConsentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Método para deletar/revogar o consentimento identificado por consentId.
         * @summary Deletar/revogar o consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<void> {
            return ConsentsApiFp(configuration).consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para obter detalhes do consentimento identificado por consentId.
         * @summary Obter detalhes do consentimento identificado por consentId.
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsent | ResponseConsentFull> {
            return ConsentsApiFp(configuration).consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Criar novo pedido de consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {CreateConsent} createConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsent> {
            return ConsentsApiFp(configuration).consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * Método para a criação de um novo consentimento.
         * @summary Update the consent API
         * @param {string} consentId Identificador do consentimento.
         * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
         * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<ResponseConsentFull> {
            return ConsentsApiFp(configuration).consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
    };
};

/**
 * ConsentsApi - object-oriented interface
 * @export
 * @class ConsentsApi
 * @extends {BaseAPI}
 */
export class ConsentsApi extends BaseAPI {
    /**
     * Método para deletar/revogar o consentimento identificado por consentId.
     * @summary Deletar/revogar o consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsDeleteConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsDeleteConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para obter detalhes do consentimento identificado por consentId.
     * @summary Obter detalhes do consentimento identificado por consentId.
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsGetConsentsConsentId(consentId: string, authorization: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsGetConsentsConsentId(consentId, authorization, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para a criação de um novo consentimento.
     * @summary Criar novo pedido de consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {CreateConsent} createConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsPostConsents(authorization: string, createConsent: CreateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsPostConsents(authorization, createConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * Método para a criação de um novo consentimento.
     * @summary Update the consent API
     * @param {string} consentId Identificador do consentimento.
     * @param {string} authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
     * @param {UpdateConsent} updateConsent Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsentsApi
     */
    public consentsPutConsents(consentId: string, authorization: string, updateConsent: UpdateConsent, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ConsentsApiFp(this.configuration).consentsPutConsents(consentId, authorization, updateConsent, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

}


/**
 * OpenIDProviderApi - axios parameter creator
 * @export
 */
export const OpenIDProviderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): RequestArgs {
            const localVarPath = `/backchannel`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): RequestArgs {
            const localVarPath = `/device/auth`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            const localVarPath = `/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling regClientIdDelete.');
            }
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling regClientIdGet.');
            }
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling regClientIdPut.');
            }
            const localVarPath = `/reg/{ClientId}`
                .replace(`{${"ClientId"}}`, encodeURIComponent(String(clientId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): RequestArgs {
            const localVarPath = `/reg`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): RequestArgs {
            const localVarPath = `/request`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options: any = {}): RequestArgs {
            const localVarPath = `/token/introspection`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'introspectionRequest' is not null or undefined
            if (introspectionRequest === null || introspectionRequest === undefined) {
                throw new RequiredError('introspectionRequest','Required parameter introspectionRequest was null or undefined when calling tokenPost.');
            }
            const localVarPath = `/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFapiAuthDate !== undefined && xFapiAuthDate !== null) {
                localVarHeaderParameter['x-fapi-auth-date'] = String(xFapiAuthDate);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof introspectionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(introspectionRequest !== undefined ? introspectionRequest : {}) : (introspectionRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenIDProviderApi - functional programming interface
 * @export
 */
export const OpenIDProviderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Introspection> {
            const localVarAxiosArgs = OpenIDProviderApiAxiosParamCreator(configuration).tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OpenIDProviderApi - factory interface
 * @export
 */
export const OpenIDProviderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Post a Oauth 2.0 ciba request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Post a request to the device endpoint to retrieve a token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets the user information stored in OpenId Provider
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete an oauth client. Cascade delete all child details
         * @param {string} clientId The ClientId to be deleted
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update an oauth client by Id
         * @param {string} clientId The oauth ClientId
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Create a client
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Post a Oauth 2.0 pushed authorization request
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {IntrospectionRequest} [introspectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Post a request to the token endpoint to retrieve a token
         * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
         * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
         * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
         * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): AxiosPromise<Introspection> {
            return OpenIDProviderApiFp(configuration).tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
    };
};

/**
 * OpenIDProviderApi - object-oriented interface
 * @export
 * @class OpenIDProviderApi
 * @extends {BaseAPI}
 */
export class OpenIDProviderApi extends BaseAPI {
    /**
     * 
     * @summary Post a Oauth 2.0 ciba request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public backchannelPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).backchannelPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Post a request to the device endpoint to retrieve a token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public deviceAuthPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).deviceAuthPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets the user information stored in OpenId Provider
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public meGet(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).meGet(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete an oauth client. Cascade delete all child details
     * @param {string} clientId The ClientId to be deleted
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdDelete(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdDelete(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdGet(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdGet(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update an oauth client by Id
     * @param {string} clientId The oauth ClientId
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regClientIdPut(clientId: string, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regClientIdPut(clientId, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Create a client
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public regPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).regPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Post a Oauth 2.0 pushed authorization request
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public requestPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).requestPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Post a Oauth 2.0 token and return a JSON payload representing meta information surrounding the token
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {IntrospectionRequest} [introspectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public tokenIntrospectionPost(xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, introspectionRequest?: IntrospectionRequest, options?: any) {
        return OpenIDProviderApiFp(this.configuration).tokenIntrospectionPost(xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, introspectionRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Post a request to the token endpoint to retrieve a token
     * @param {IntrospectionRequest} introspectionRequest Payload para criação do consentimento.
     * @param {string} [xFapiAuthDate] Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] O endereço IP do usuário se estiver atualmente logado com o receptor.
     * @param {string} [xFapiInteractionId] Um UID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação. Se fornecido, o transmissor deve \&quot;reproduzir\&quot; esse valor no cabeçalho de resposta.
     * @param {string} [xCustomerUserAgent] Indica o user-agent que o usuário utiliza.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenIDProviderApi
     */
    public tokenPost(introspectionRequest: IntrospectionRequest, xFapiAuthDate?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return OpenIDProviderApiFp(this.configuration).tokenPost(introspectionRequest, xFapiAuthDate, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

}


